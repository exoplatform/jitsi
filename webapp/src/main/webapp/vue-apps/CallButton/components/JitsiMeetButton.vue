<template>
  <v-btn
    ref="jitsi"
    class="myCallAction"
    outlined="true"
    height="33px"
    min-width="fit-content"
    @click.native="startCall">
    <i class="uiIconMyCall uiIconVideoPortlet uiIconLightGray"></i>
    {{ i18n.te("UICallButton.label.jitsi")
      ? $t("UICallButton.label.jitsi")
    : "Call with Jitsi" }}
  </v-btn>
</template>


<script>
export default {
  props: {
    callSettings: {
      type: Object,
      required: true
    },
    i18n: {
      type: Object,
      required: true
    },
    language: {
      type: String,
      required: true
    },
    resourceBundleName: {
      type: String,
      required: true
    }
  },

  data: function() {
    return {
      // callButtonClass: "",
      settings: this.callSettings,
      log: null,
      callWindow: null,
      // eslint-disable-next-line quotes
      // icon: `<i class="uiIconMyCall uiIconVideoPortlet uiIconLightGray"></i>`,
    //   call: this.i18n.te("UICallButton.label.jitsi")
    //   ? this.$t("UICallButton.label.jitsi")
    // : "Call with Jitsi" 
    };
  },
  created() {
    this.log = webConferencing.getLog("jitsi");
  },
  mounted() {
    // Assign target ID to the button for later use on started
    // event in init()
    //const callButton = this.$refs.jitsi;
    //callButton.$el.dataset.targetid = this.settings.target.id;
  },
  methods: {
    startCall: function (event) {
      const thevue = this;
      this.log.trace("Click on Jitsi call button");
      // handle only of not disabled (see init())
      //  if (!$button.hasClass("callDisabled")) {
      // When user clicked the button - create an actual call.
      // Use Web Conferencing helper to open a new window
      // Build a call page URL on your own and for your needs.

      // You can save this call in eXo to inform other parts and
      // be able restore the call in case of page reload
      // or on other Platform pages. Respectively, you'll need
      // to delete the call - this could be done from a call
      // page, but also may be done from server-side (on some
      // event, external call, timer, etc.).
      // Find a way informing end of the call from your actual
      // connector capabilities.
      //
      // Adding (and then removing) a call is not mandatory. If
      // your call provider inform other parts about the call
      // by itself (e.g. via native app), you can skip
      // adding/removing calls.
      //
      // To save a new call we need an ID with some info about
      // an owner, its type, provider, title and participants.
      // Call ID should be generated by a connector, there is no
      // restrictions for how ID should look,
      // but it's recommended to keep it without spaces and
      // friendly to URLs.
      // Below we construct an ID to simply identify call on
      // both portal and chat pages:
      // * for group call we prefix with (g/) with group ID
      // (effectively:
      // - for spaces we want space_name (known as pretty name,
      // e.g. product_team) and
      // if it's space room in chat we use roomName from the
      // context
      // - for chat room its room-name (e.g. space-121218554...
      // or team-8978676565...)
      // * for 1:1 prefix (p/) appended with participant IDs
      // sorted always in same order.
      // XXX Call ID should only contain characters supported by
      // CometD,
      // find more in
      // https://docs.cometd.org/current/reference/#_bayeux_protocol_elements
      let callId;
      if (this.settings.target.group) {
        callId = `g_${(this.settings.target.type === "chat_room" ? this.settings.context.roomName : this.settings.target.id)}`;
      } else {
        // Sort call members to have always the same ID for two
        // parts independently on who started the call
        const callMembersAsc = this.settings.callMembers.map(function(member) {
          return member.id;
        }).slice();
        callMembersAsc.sort();
        callId = `p_${callMembersAsc.join("-")}`;
      }
      this.log.trace(`Jitsi call id: ${callId}`);

      const callUrl = `${window.location.protocol}//${window.location.host}/jitsi/meet/${callId}`;

      // Next we need ensure this call not yet already started
      // (e.g. remotely),
      // it's actual especially for group calls where user can
      // join already running conversations
      // As we have two cases: new call and joining a call, we
      // use promise to complete the call page for any of cases
      // depending on asynchronous requests to the server.
      //var callProcess = $.Deferred();
      const callProcess = new Promise((resolve,reject) => {
        // Open call window before asynchronous requests to avoid
        // browser's popup blocker
        // window title
        // visible to
        // user
        // Try get a call by the ID to know is it exists already -
        // it why we need stable ID clearly defining the target
        webConferencing.getCall(callId).done(function(call) {
          // Call already running - join it
          thevue.log.info(`Joining call: ${callId}`);
          // For group calls
          if (call.state === "stopped" && (thevue.settings.target.type === "space" || thevue.settings.target.type === "chat_room")) {
            webConferencing.updateCall(callId, "started").done(function(){
              thevue.log.info(`Changed call state to started: ${callId}`);
            });
          }
          
          const promiseResult = {
            call: call,
            isNew: false
          };
          resolve(promiseResult);
        }).fail(function(err) {
          if (err) {
            if (err.code === "NOT_FOUND_ERROR") {
              const participatntsIds = thevue.settings.callMembers.map(function(member) {
                return member.id;
              }).join(";");
              // OK, this call not found - start a new one,
              const callInfo = {
                // for group calls an owner is a group entity
                // (space or room), otherwise it's 1:1 and who
                // started is an owner
                owner : thevue.settings.target.group ? thevue.settings.target.id : thevue.settings.context.currentUser.id,
                // ownerType can be 'user' for 1:1 calls, 'space'
                // for group call in space, 'chat_room' for group
                // call in Chat room
                ownerType : thevue.settings.target.type, // use target type
                provider : thevue.settings.provider.getType(),
                // tagret's title is a group or user full name
                title : thevue.settings.target.title,
                participants : participatntsIds
                // string build from array separated by ';'
              };
              webConferencing.addCall(callId, callInfo).done(function(call) {
                thevue.log.info(`Call created: ${callId}`);
                const promiseResult = {
                  call: call,
                  isNew: true
                };
                resolve(promiseResult);
              });
            } else {
              thevue.log.error(`Failed to get call info: ${callId}`, err);
              webConferencing.showError("Joining call error", webConferencing.errorText(err));
            }
          } else {
            thevue.log.error(`Failed to get call info: ${callId}`);
            webConferencing.showError("Joining call error", "Error read call information from the server");
          }
        });
      });

      // We wait for call readiness and invoke start it in the
      // popup window
      callProcess.then(function(promiseResult) {
        thevue.log.trace("Call is ready for opening");
        const call = promiseResult.call;
        const isNew = promiseResult.isNew;
        const callWindow = thevue.callWindow = webConferencing.showCallPopup(callUrl, thevue.settings.target.title);
        callWindow.document.title = thevue.settings.target.title;


        let callStarted = false;
        // TODO: move this listener to button init phase
        // Now it's executed every time the button clicked
        webConferencing.onCallUpdate(callId, function(update) {
          thevue.log.debug(`Received update: ${JSON.stringify(update)}`);
          if (update.exoId === thevue.settings.context.currentUser.id && update.action === "started") {
            callStarted = true;
          }
        });
        // Delete call if it hasn't been started for 15 secs after openning the call page
        setTimeout(function(){
          if (!callStarted) {
            // Smth went wrong on call page. Delete call.
            webConferencing.deleteCall(callId).then(function(){
              thevue.log.debug(`The call ${callId} hasn't been started. Deleted call`);
            });
          }
        }, 15000);

        callWindow.addEventListener("load", function() {
          thevue.log.trace("Call Window is loaded");
        });
      });
    }
  },
};
</script>
<style>
  .VuetifyApp button:not(.ignore-vuetify-classes), .VuetifyApp input:not(.ignore-vuetify-classes), .VuetifyApp select:not(.ignore-vuetify-classes), .VuetifyApp textarea:not(.ignore-vuetify-classes) {
    background-color: transparent;
    border: 1px solid #e1e8ee;
    border-radius: 2px;
  }
</style>