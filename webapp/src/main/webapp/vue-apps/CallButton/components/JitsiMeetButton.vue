<template>
  <v-btn
    id="jitsiCallButton"
    :click="startCall()"
    color="white"
    elevation="1"
    class="myCallAction">
    <i class="uiIconMyCall uiIconVideoPortlet uiIconLightGray"></i>
    {{ i18n.te('UICallButton.label.jitsi')
      ? $t('UICallButton.label.jitsi')
    : 'Call with Jitsi' }}
  </v-btn>
</template>


<script>

export default {

  data: function() {
    return {
      callSettings: {},
      callButtonClass: ""
    };
  },
  created() {
    this.target = this.callSettings.target;
    this.context = this.callSettings.context;
    this.callMembers = this.callSettings.callMembers;
    this.callWindow = this.callSettings.callWindow;
    this.log = webConferencing.getLog("jitsi");
  },
  mounted() {
    // Assign target ID to the button for later use on started
    // event in init()
    const callButton = document.getElementById("jitsiCallButton");
    callButton.dataset.targetid = this.target.id;
  },
  methods: {
    startCall: function (event) {
      const thevue = this;
      // handle only of not disabled (see init())
      //  if (!$button.hasClass("callDisabled")) {
      // When user clicked the button - create an actual call.
      // Use Web Conferencing helper to open a new window
      // Build a call page URL on your own and for your needs.

      // You can save this call in eXo to inform other parts and
      // be able restore the call in case of page reload
      // or on other Platform pages. Respectively, you'll need
      // to delete the call - this could be done from a call
      // page, but also may be done from server-side (on some
      // event, external call, timer, etc.).
      // Find a way informing end of the call from your actual
      // connector capabilities.
      //
      // Adding (and then removing) a call is not mandatory. If
      // your call provider inform other parts about the call
      // by itself (e.g. via native app), you can skip
      // adding/removing calls.
      //
      // To save a new call we need an ID with some info about
      // an owner, its type, provider, title and participants.
      // Call ID should be generated by a connector, there is no
      // restrictions for how ID should look,
      // but it's recommended to keep it without spaces and
      // friendly to URLs.
      // Below we construct an ID to simply identify call on
      // both portal and chat pages:
      // * for group call we prefix with (g/) with group ID
      // (effectively:
      // - for spaces we want space_name (known as pretty name,
      // e.g. product_team) and
      // if it's space room in chat we use roomName from the
      // context
      // - for chat room its room-name (e.g. space-121218554...
      // or team-8978676565...)
      // * for 1:1 prefix (p/) appended with participant IDs
      // sorted always in same order.
      // XXX Call ID should only contain characters supported by
      // CometD,
      // find more in
      // https://docs.cometd.org/current/reference/#_bayeux_protocol_elements
      let callId;
      if (thevue.target.group) {
        callId = `g_${(thevue.target.type === "chat_room" ? thevue.context.roomName : thevue.target.id)}`;
      } else {
        // Sort call members to have always the same ID for two
        // parts independently on who started the call
        const callMembersAsc = thevue.callMembers.map(function(member) {
          return member.id;
        }).slice();
        callMembersAsc.sort();
        callId = `p_${callMembersAsc.join("-")}`;
      }

      const callUrl = `${window.location.protocol}//${window.location.host}/jitsi/meet/${callId}`;

      // Next we need ensure this call not yet already started
      // (e.g. remotely),
      // it's actual especially for group calls where user can
      // join already running conversations
      // As we have two cases: new call and joining a call, we
      // use promise to complete the call page for any of cases
      // depending on asynchronous requests to the server.
      //var callProcess = $.Deferred();
      const callProcess = new Promise((resolve,reject) => {
        // Open call window before asynchronous requests to avoid
        // browser's popup blocker
        // window title
        // visible to
        // user
        // Try get a call by the ID to know is it exists already -
        // it why we need stable ID clearly defining the target
        webConferencing.getCall(callId).done(function(call) {
          // Call already running - join it
          thevue.log.info(`Joining call: ${callId}`);
          const promiseResult = {
            call: call,
            isNew: false
          };
          resolve(promiseResult);
        }).fail(function(err) {
          if (err) {
            if (err.code === "NOT_FOUND_ERROR") {
              const participatntsIds = thevue.callMembers.map(function(member) {
                return member.id;
              }).join(";");
              // OK, this call not found - start a new one,
              const callInfo = {
                // for group calls an owner is a group entity
                // (space or room), otherwise it's 1:1 and who
                // started is an owner
                owner : thevue.target.group ? thevue.target.id : thevue.context.currentUser.id,
                // ownerType can be 'user' for 1:1 calls, 'space'
                // for group call in space, 'chat_room' for group
                // call in Chat room
                ownerType : thevue.target.type, // use target type
                provider : self.getType(),
                // tagret's title is a group or user full name
                title : thevue.target.title,
                participants : participatntsIds
                // string build from array separated by ';'
              };
              webConferencing.addCall(callId, callInfo).done(function(call) {
                thevue.log.info(`Call created: ${callId}`);
                const promiseResult = {
                  call: call,
                  isNew: true
                };
                resolve(promiseResult);
              });
            } else {
              thevue.log.error(`Failed to get call info: ${callId}`, err);
              webConferencing.showError("Joining call error", webConferencing.errorText(err));
            }
          } else {
            thevue.log.error(`Failed to get call info: ${callId}`);
            webConferencing.showError("Joining call error", "Error read call information from the server");
          }
        });
      });

      // We wait for call readiness and invoke start it in the
      // popup window
      callProcess.then(function(promiseResult) {
        const call = promiseResult.call;
        const isNew = promiseResult.isNew;
        const callWindow = thevue.callWindow = webConferencing.showCallPopup(callUrl, thevue.target.title);
        callWindow.document.title = thevue.target.title;


        let callStarted = false;
        webConferencing.onCallUpdate(callId, function(update){
          console.log(`Received update: ${JSON.stringify(update)}`);
          if (update.exoId === thevue.context.currentUser.id && update.action === "started") {
            callStarted = true;
          }
        });
        // Delete call if it hasn't been started for 15 secs after openning the call page
        setTimeout(function(){
          if (!callStarted) {
            // Smth went wrong on call page. Delete call.
            webConferencing.deleteCall(callId).then(function(){
              console.log(`The call ${callId} hasn't been started. Deleted call`);
            });
          }
        }, 15000);


        // Next, we invoke a call window to initialize the call.
        // Note: it's assumed below that startCall() method
        // added by the call page script,
        // it is not defined in Web Conferencing module. You can
        // use any namespace and way to invoke your
        // connector methods - it's up to the implementation.
        // Ensure the call window loaded before calling it.
        callWindow.addEventListener("load", function() {
          const callButton = document.getElementById("jitsiCallButton");

          callButton.classList.add("callDisabled"); // should be

          // removed
          // on
          // stop/leaved
          // event in
          // init()
          callButton.dataset.callid = callId; // Assign call
          // ID to the
          // button for
          // later use
          // (see above)

        });
      });
    }
  }
};
</script>